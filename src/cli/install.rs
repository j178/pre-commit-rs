use std::fmt::Write as _;
use std::io::Write;
use std::path::{Path, PathBuf};

use anyhow::Result;
use indoc::indoc;
use owo_colors::OwoColorize;

use crate::cli::run;
use crate::cli::{ExitStatus, HookType};
use crate::fs::Simplified;
use crate::git;
use crate::hook::Project;
use crate::printer::Printer;
use crate::store::Store;

pub(crate) async fn install(
    config: Option<PathBuf>,
    hook_types: Vec<HookType>,
    install_hooks: bool,
    overwrite: bool,
    allow_missing_config: bool,
    printer: Printer,
) -> Result<ExitStatus> {
    if git::has_hooks_path_set().await? {
        writeln!(
            printer.stderr(),
            indoc::indoc! {"
                Cowardly refusing to install hooks with `core.hooksPath` set.
                hint: `git config --unset-all core.hooksPath` to fix this.
            "}
        )?;
        return Ok(ExitStatus::Failure);
    }

    let mut project = Project::from_config_file(config)?;

    let hooks_types = if hook_types.is_empty() {
        project
            .config()
            .default_install_hook_types
            .clone()
            .unwrap_or_else(|| vec![HookType::PreCommit])
    } else {
        hook_types
    };

    let hooks_path = git::get_git_common_dir().await?.join("hooks");
    fs_err::create_dir_all(&hooks_path)?;

    for hook_type in hooks_types {
        install_hook_script(
            project.config_file(),
            hook_type,
            &hooks_path,
            overwrite,
            allow_missing_config,
            printer,
        )?;
    }

    if install_hooks {
        let store = Store::from_settings()?.init()?;
        let _lock = store.lock_async().await?;

        let hooks = project.init_hooks(&store, printer).await?;
        run::install_hooks(&hooks, printer).await?;
    }

    Ok(ExitStatus::Success)
}

fn install_hook_script(
    config_file: &Path,
    hook_type: HookType,
    hooks_path: &Path,
    overwrite: bool,
    skip_on_missing_config: bool,
    printer: Printer,
) -> Result<()> {
    let hook_path = hooks_path.join(hook_type.as_str());

    if hook_path.try_exists()? {
        if overwrite {
            writeln!(
                printer.stdout(),
                "Overwriting existing hook at {}",
                hook_path.user_display().cyan()
            )?;
        } else {
            if !is_our_script(&hook_path)? {
                let legacy_path = format!("{}.legacy", hook_path.display());
                fs_err::rename(&hook_path, &legacy_path)?;
                writeln!(
                    printer.stdout(),
                    "Hook already exists at {}, move it to {}.",
                    hook_path.user_display().cyan(),
                    legacy_path.user_display().yellow()
                )?;
            }
        }
    }

    let mut args = vec![
        "hook-impl".to_string(),
        format!("--config={}", config_file.user_display()),
        format!("--hook-type={}", hook_type.as_str()),
    ];
    if skip_on_missing_config {
        args.push("--skip-on-missing-config".to_string());
    }

    let args = shlex::try_join(args.iter().map(String::as_str))?;
    let hook_script = HOOK_TMPL.replace("ARGS=(hook-impl)", &format!("ARGS=({args})"));
    fs_err::OpenOptions::new()
        .write(true)
        .create(true)
        .open(&hook_path)?
        .write_all(hook_script.as_bytes())?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;

        let mut perms = hook_path.metadata()?.permissions();
        perms.set_mode(0o755);
        fs_err::set_permissions(&hook_path, perms)?;
    }

    writeln!(
        printer.stdout(),
        "pre-commit installed at {}",
        hook_path.user_display().cyan()
    )?;

    Ok(())
}

static HOOK_TMPL: &str = indoc! { r#"
#!/usr/bin/env bash
# File generated by pre-commit: https://pre-commit.com
# ID: 138fd403232d2ddd5efb44317e38bf03

ARGS=(hook-impl)

HERE="$(cd "$(dirname "$0")" && pwd)"
ARGS+=(--hook-dir "$HERE" -- "$@")

if command -v pre-commit > /dev/null; then
    exec pre-commit "${ARGS[@]}"
else
    echo '`pre-commit` not found.  Did you forget to activate your virtualenv?' 1>&2
    exit 1
fi
"#
};

static PRIOR_HASHES: &[&str] = &[
    "4d9958c90bc262f47553e2c073f14cfe",
    "d8ee923c46731b42cd95cc869add4062",
    "49fd668cb42069aa1b6048464be5d395",
    "79f09a650522a87b0da915d0d983b2de",
    "e358c9dae00eac5d06b38dfdb1e33a8c",
];

static CURRENT_HASH: &str = "138fd403232d2ddd5efb44317e38bf03";

/// Checks if the script contains any of the hashes that `pre-commit` has used in the past.
fn is_our_script(hook_path: &Path) -> Result<bool> {
    let content = fs_err::read_to_string(hook_path)?;
    Ok(std::iter::once(CURRENT_HASH)
        .chain(PRIOR_HASHES.iter().copied())
        .any(|hash| content.contains(hash)))
}
